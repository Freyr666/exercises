(defconstant +input+ "./input")

(defun fft-pattern-gen (base mult)
  (let ((len (length base))
        (pos 0)
        (rep 1))
    (lambda ()
      (cond ((= rep mult) 
             (setf rep 1)
             (incf pos)
             (nth (mod pos len) base))
            (t
             (incf rep)
             (nth (mod pos len) base))))))

(defun fft-pattern-next (pattern)
  (funcall pattern))

(defun test-fft-pattern ()
  (let ((p         (fft-pattern-gen '(1 0 -1 0) 3))
        (expected  '(1 1 0 0 0 -1 -1 -1 0 0 0 1)))
    (dolist (el expected)
      (assert (= el (fft-pattern-next p))))))

(defun read-input ()
  (let (acc
        (z (char-int #\0)))
    (with-open-file (stream +input+)
      (do ()
          (nil)
        (let ((c (read-char stream nil nil)))
          (if (null c)
              (return-from read-input (coerce (reverse acc) 'vector))
              (push (- (char-int c) z)
                    acc)))))))

(defvar *input-seq* (read-input))

(defun input-fft-convol (input fft)
  (let ((sum 0))
    (dotimes (i (array-dimension input 0))
      (incf sum (* (aref input i)
                   (fft-pattern-next fft))))
    (rem (abs sum) 10)))

(defun input-phase (input)
  (let* ((len    (array-dimension input 0))
         (output (make-array (list len) :element-type 'fixnum)))
    (dotimes (i len)
      (let ((fft (fft-pattern-gen '(0 1 0 -1) (1+ i))))
        (setf (aref output i)
              (input-fft-convol input fft))))
    output))

(defun solve-part-1 ()
  (let ((dat *input-seq*))
    (dotimes (phase 100)
      (setf dat (input-phase dat)))
    (subseq dat 0 8)))

(defun repeat (array times)
  (let* ((len (array-dimension array 0))
         (res (make-array (list (* len times)) :element-type 'fixnum)))
    (dotimes (i (array-dimension res 0))
      (setf (aref res i)
            (aref array (rem i len))))
    res))

(defun calc-offset (input)
  (let ((arr (subseq input 0 8)))
    (reduce (lambda (acc x) (+ (* 10 acc) x)) arr)))

(defun brut-solve-part-2 ()
  (let ((dat (repeat *input-seq* 10000)))
    (dotimes (phase 100)
      (format t "Phase number: ~A~%" phase)
      (setf dat (input-phase dat)))
    (let ((offset (calc-offset *input-seq*)))
      (subseq dat offset (+ offset 8)))))
